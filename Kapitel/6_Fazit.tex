\section{Abschließende Überlegungen}
Dieses Kapitel schließt das Thema Vektoruhren in dieser Arbeit ab. Neben einer Zusammenfassung der gesamten Arbeit einschließlich eines Fazits zu den einzelnen Themen wird ein Ausblick gegeben, wie man die Verwendung von Vektoruhren in einem Verteilten System noch verbessern und erweitern kann.
\subsection{Fazit}
In dieser Arbeit wurde zunächst beschrieben, wie ein Verteiltes System aufgebaut ist und welche Besonderheiten sich dabei ergeben. Nach einer Erklärung, weshalb es wichtig ist, Ausgetauschte Nachrichten in einem solchen System in eine gewisse kausale Ordnung zu bringen, fand eine Aufzählung der wichtigsten Uhrkonzepte statt. Neben den naheliegenden, physikalischen Uhren wurden die für das Thema dieser Arbeit interessanten logischen Uhren eingeführt und kurz deren Funktionsweise angeschnitten. Besonders hier hat sich bereits herausgestellt, dass Vektoruhren im Bereich der logischen Uhren die erfolgversprechendsten Funktionen bieten.

Nach der Einführung fand eine genauere Erklärung statt, wie Vektoruhren funktionieren. Diese wurde anhand von Beispielen näher erläutert und die Umsetzung in der Programmiersprache C\# präsentiert. Da sich bei dem Einsatz von Vektoruhren einigen Schwierigkeiten aufzeigen lassen, wurden einige davon in Kapitel Vier beschrieben. Hier wurden schnell die Grenzen der Uhren ersichtlich, nämlich dass Vektoruhren grundsätzlich nur bei statischen Systemen mit einer festen Anzahl an Prozessen funktionieren und die Größe der zu speichernden Uhren mit jedem weiteren Prozess stark zunimmt, was den gesamten Datenverkehr in die Höhe treibt. Auch machen Events, welche zum selben Zeitpunkt abgesendet werden, für eine reine Vektoruhr-Implementierung probleme und lösen Konflikte aus.

Eine Besonderheit im Thema Vektoruhren stellt der Causally Ordered Multicast dar. Da dieser eine großen Mehrwert für die Anwendungsebene eines verteilten Systems haben kann, befasste sich der Autor in Kapitel 5 mit diesem Thema und ging auch hier wieder auf eine mögliche Umsetzung eines solchen Systems in C\# ein. Der Mehrwert bedeutet dabei, dass mit dieser Art des Multicasts Absendereihenfolgen von Absendern mit der Empfangsreihenfolge von Nachrichten an den Empfängern aufeinander abgestimmt werden können, was für viele Anwendungen von Großer Bedeutung sein kann. Als Beispiel wurde hierbei eine Aktualisierung von Kontostände in einem Bankkonto-Szenario angeführt.

Neben den Eigenschaften des Causally Ordered Mulitcast wurde in diesem Kapitel zudem noch auf die besondere Rolle der Anwendungsschicht in einem verteilten System eingegangen. Wie sich herausstellte, macht eine kausale Ordnung von ankommenden Nachrichten erst im Kontext der Anwendung Sinn. So hängt es von dem tatsächlichen Anwendungsfall des verteilten Systems ab, ob zum Beispiel Nachrichten als zu löschend markiert werden können, wann alten Nachrichten tatsächlich gelöscht werden und welche Daten durch einen Prozess in einem Event verändert wurden. Im Sonderfall kann sich dadurch die Bedeutung von kausalen Zusammenhängen der ausgetauschten Nachrichten ändern.

Abschließend bleibt zu sagen, dass sich Vektoruhren sehr gut für die Ordnung und Sortierung von ausgetauschten Nachrichten in verteilten Systemen eignen. Durch Erweiterungen wie etwa dem Causally Ordered Multicasts kann dies sogar noch gezielter geschehen. Man darf jedoch nicht zu viel von der Funktionsweise der Uhren erwarten. Sie dienen lediglich als Basis und unterstützen die Anwendungsschicht dabei, sinnvoll mit ankommenden Nachrichten umzugehen und diese im Kontext des Anwendungsziels zu verarbeiten. Fehler auf dem Übertragungsweg oder der Ausfall von beteiligten Prozessen können durch Vektoruhren lediglich erkannt, jedoch nicht direkt verhindern oder ausgebessert werden. Dies bleibt weiterhin Aufgabe der Anwendungsebene.
\subsection{Ausblick}
Die grundlegende Funktionsweise von Vektoruhren ist bereits ein sehr interessantes und umfangreiches Thema. In der Literatur finden sich aufbauend darauf noch viele weitere Einsatzmöglichkeiten für diese Art der logischen Uhren.

Dabei lassen sich grundsätzlich zwei verschiedene Varianten unterscheiden. Die erste nimmt Vektoruhren als Basis und ändert deren Funktionalität derart ab, sodass damit ein spezielles Problem gelöst werden kann. Im Folgenden werden einige Beispiele aus der Literatur aufgezeigt.

Die effiziente Speicherung von Vektoruhren ist, wie sich herausgestellt hat, in großen Systemen mit vielen beteiligten Prozessen ein Problem. Neben der in dieser Arbeit vorgestellten Lösung über Matrixuhren gibt es noch weitere, weitaus effizientere aber auch komplexere Ansätze für die Lösung dieses Problems. Eines davon sind die \cite{Gidenstam2004} vorgestellten NUREV-Clocks, was ausgeschreiben für \texttt{Non-Uniformly Mapped R-Entries Vector Clocks} steht. Die Idee dieser Art von Uhren ist es, eine dynamische Zuordnung zwischen den Prozessen in System und deren Einträgen in der Vektoruhr zu schaffen und dabei die Vektorgröße zu beschränken. Im herkömmlichen Fall ist diese starr, jeder Prozess hat also eine feste ID. Die Zuordnungen können während der Laufzeit dann dynamisch angepasst und optimiert werden, was im Endeffekt eine effizientere Speicherung und Übertragung der Vektoruhren während der Kommunikation ermöglicht.

TODO:HVC erklären... nochmal genau nachlesen!

Ein etwas anderer Anwendungsfall ist eine Ordnung von Events in parallel arbeitenden Systemen. Diese arbeiten nicht verteilt, aber dafür mit mehreren, gleichzeitig ausgeführten Tasks. Im Programmablauf eines solchen Systems wechseln sich sequentielle und parallele Ausführungsschritte ab, was auch als \texttt{Nested Paralellism} bezeichnet wird. Die in \cite{Audenaert1997} beschriebene Methode setzt dabei auf die Technik der \textit{Clock Trees}. 
TODO: Grobe Funktionsweise.



Die zweite Variante nimmt Vektoruhren in der Funktionsweise, wie sie in dieser Arbeit auch beschrieben wurde und setzt sie für Anwendungen ein, die sich von der Ursprünglichen Idee der kausalen Ordnung von Nachrichten in verteilten Systemen unterscheidet. Ein erstes Beispiel hierfür ist das finden von Abhängigkeiten in Web-Services, wie es in \cite{Romano2011} durchgeführt wird. Romano et al. haben in ihrer Arbeit eine Methode entwickelt, wie man die Zusammenhänge unterschiedlicher, zusammenarbeitender Web-Services durch den Einsatz von Vektoruhren untersuchen kann. Das Problem bei solchen Systemen ist häufig, das dieses Zusammenspiel undurchsichtig ist und der Aufbau von serviceorientierte Architekturen schwer nachvollzogen werden kann. Eine direkte Folge stellt dabei die leichte Verbesserung der Antwortzeiten des in \cite{Romano2011} beschriebenen Systems durch eine solche Analyse und Anpassung dar.


Wie man sehen kann, eröffnete die Erfindung von logischen Uhren im allgemeinen und Vektoruhren im speziellen den Weg für viele interessante Weiterentwicklungen. 
%Version Vector