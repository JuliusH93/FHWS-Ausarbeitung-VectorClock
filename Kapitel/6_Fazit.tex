\section{Abschließende Überlegungen}
Dieses Kapitel schließt das Thema Vektoruhren in dieser Arbeit ab. Neben einer Zusammenfassung der gesamten Arbeit einschließlich eines Fazits zu den einzelnen Themen wird ein Ausblick gegeben, wie man die Verwendung von Vektoruhren in einem Verteilten System noch verbessern und erweitern kann.
\subsection{Fazit}
In dieser Arbeit wurde zunächst beschrieben, wie ein Verteiltes System aufgebaut ist und welche Besonderheiten sich dabei ergeben. Nach einer Erklärung, weshalb es wichtig ist, Ausgetauschte Nachrichten in einem solchen System in eine gewisse kausale Ordnung zu bringen, fand eine Aufzählung der wichtigsten Uhrkonzepte statt. Neben den naheliegenden, physikalischen Uhren wurden die für das Thema dieser Arbeit interessanten logischen Uhren eingeführt und kurz deren Funktionsweise angeschnitten. Besonders hier hat sich bereits herausgestellt, dass Vektoruhren im Bereich der logischen Uhren die erfolgversprechendsten Funktionen bieten.

Nach der Einführung fand eine genauere Erklärung statt, wie Vektoruhren funktionieren. Diese wurde anhand von Beispielen näher erläutert und die Umsetzung in der Programmiersprache C\# präsentiert. Da sich bei dem Einsatz von Vektoruhren einigen Schwierigkeiten aufzeigen lassen, wurden einige davon in Kapitel Vier beschrieben. Hier wurden schnell die Grenzen der Uhren ersichtlich, nämlich dass Vektoruhren grundsätzlich nur bei statischen Systemen mit einer festen Anzahl an Prozessen funktionieren und die Größe der zu speichernden Uhren mit jedem weiteren Prozess stark zunimmt, was den gesamten Datenverkehr in die Höhe treibt. Auch machen Events, welche zum selben Zeitpunkt abgesendet werden, für eine reine Vektoruhr-Implementierung probleme und lösen Konflikte aus.

Eine Besonderheit im Thema Vektoruhren stellt der Causally Ordered Multicast dar. Da dieser eine großen Mehrwert für die Anwendungsebene eines verteilten Systems haben kann, befasste sich der Autor in Kapitel 5 mit diesem Thema und ging auch hier wieder auf eine mögliche Umsetzung eines solchen Systems in C\# ein. Der Mehrwert bedeutet dabei, dass mit dieser Art des Multicasts Absendereihenfolgen von Absendern mit der Empfangsreihenfolge von Nachrichten an den Empfängern aufeinander abgestimmt werden können, was für viele Anwendungen von Großer Bedeutung sein kann. Als Beispiel wurde hierbei eine Aktualisierung von Kontostände in einem Bankkonto-Szenario angeführt.

Neben den Eigenschaften des Causally Ordered Mulitcast wurde in diesem Kapitel zudem noch auf die besondere Rolle der Anwendungsschicht in einem verteilten System eingegangen. Wie sich herausstellte, macht eine kausale Ordnung von ankommenden Nachrichten erst im Kontext der Anwendung Sinn. So hängt es von dem tatsächlichen Anwendungsfall des verteilten Systems ab, ob zum Beispiel Nachrichten als zu löschend markiert werden können, wann alten Nachrichten tatsächlich gelöscht werden und welche Daten durch einen Prozess in einem Event verändert wurden. Im Sonderfall kann sich dadurch die Bedeutung von kausalen Zusammenhängen der ausgetauschten Nachrichten ändern.

Abschließend bleibt zu sagen, dass sich Vektoruhren sehr gut für die Ordnung und Sortierung von ausgetauschten Nachrichten in verteilten Systemen eignen. Durch Erweiterungen wie etwa dem Causally Ordered Multicasts kann dies sogar noch gezielter geschehen. Man darf jedoch nicht zu viel von der Funktionsweise der Uhren erwarten. Sie dienen lediglich als Basis und unterstützen die Anwendungsschicht dabei, sinnvoll mit ankommenden Nachrichten umzugehen und diese im Kontext des Anwendungsziels zu verarbeiten. Fehler auf dem Übertragungsweg oder der Ausfall von beteiligten Prozessen können durch Vektoruhren lediglich erkannt, jedoch nicht direkt verhindern oder ausgebessert werden. Dies bleibt weiterhin Aufgabe der Anwendungsebene.
\subsection{Ausblick}
%Version Vector