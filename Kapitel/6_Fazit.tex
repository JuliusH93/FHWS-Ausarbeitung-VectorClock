\section{Abschließende Überlegungen}
Dieses Kapitel schließt das Thema Vektoruhren dieser Arbeit ab. Neben einer Zusammenfassung der gesamten Arbeit einschließlich eines Fazits zu den einzelnen Themen wird ein Ausblick gegeben, wie man die Verwendung von Vektoruhren in einem Verteilten System noch verbessern und erweitern kann.
\subsection{Fazit}
In dieser Arbeit wurde zunächst beschrieben, wie ein Verteiltes System aufgebaut ist und welche Besonderheiten sich dabei ergeben. Nach einer Erklärung, weshalb es wichtig ist, Ausgetauschte Nachrichten in einem solchen System in eine gewisse kausale Ordnung zu bringen, fand eine Aufzählung der wichtigsten Uhrkonzepte statt. Neben den naheliegenden, physikalischen Uhren wurden die für das Thema dieser Arbeit interessanten logischen Uhren eingeführt und kurz deren Funktionsweise angeschnitten. Besonders hier hat sich bereits herausgestellt, dass Vektoruhren im Bereich der logischen Uhren sehr vielversprechende Funktionen bieten.

Nach der Einführung fand eine genauere Erklärung statt, wie Vektoruhren funktionieren. Diese wurde anhand von Beispielen näher erläutert und die Umsetzung in der Programmiersprache C\# präsentiert. Da sich bei dem Einsatz von Vektoruhren einigen Schwierigkeiten aufzeigen lassen, wurden einige davon in Kapitel Vier beschrieben. Hier wurden schnell die Grenzen der Uhren ersichtlich, nämlich dass Vektoruhren grundsätzlich nur bei statischen Systemen mit einer festen Anzahl an Prozessen funktionieren und die Größe der zu speichernden Uhren mit jedem weiteren Prozess stark zunimmt, was den gesamten Datenverkehr in die Höhe treibt. Auch machen Events, welche zum selben Zeitpunkt abgesendet werden, für eine reine Vektoruhr-Implementierung Probleme und lösen Konflikte aus.

Eine Besonderheit im Thema Vektoruhren stellt der Causally Ordered Multicast dar. Da dieser eine großen Mehrwert für die Anwendungsebene eines verteilten Systems haben kann, befasste sich der Autor in Kapitel 5 mit diesem Thema und ging auch hier wieder auf eine mögliche Umsetzung eines solchen Systems in C\# ein. Der Mehrwert bedeutet dabei, dass mit dieser Art des Multicasts Absendereihenfolgen von Absendern mit der Empfangsreihenfolge von Nachrichten an den Empfängern aufeinander abgestimmt werden können, was für viele Anwendungen von Großer Bedeutung sein kann. Als Beispiel wurde hierbei eine Aktualisierung von Kontoständen in einem Bankkonto-Szenario angeführt.

Neben den Eigenschaften des Causally Ordered Mulitcast wurde in diesem Kapitel zudem noch auf die besondere Rolle der Anwendungsschicht in einem verteilten System eingegangen. Wie sich herausstellte, macht eine kausale Ordnung von ankommenden Nachrichten erst im Kontext der Anwendung Sinn. So hängt es von dem tatsächlichen Anwendungsfall des verteilten Systems ab, ob zum Beispiel Nachrichten als zu löschend markiert werden können, wann alten Nachrichten tatsächlich gelöscht werden und welche Daten durch einen Prozess in einem Event verändert wurden. Im Sonderfall kann sich dadurch die Bedeutung von kausalen Zusammenhängen der ausgetauschten Nachrichten ändern.

Abschließend bleibt zu sagen, dass sich Vektoruhren sehr gut für die Ordnung und Sortierung von ausgetauschten Nachrichten in verteilten Systemen eignen. Durch Erweiterungen wie etwa dem Causally Ordered Multicasts kann dies sogar noch gezielter geschehen. Man darf jedoch nicht zu viel von der Funktionsweise der Uhren erwarten. Sie dienen lediglich als Basis und unterstützen die Anwendungsschicht dabei, sinnvoll mit ankommenden Nachrichten umzugehen und diese im Kontext des Anwendungsziels zu verarbeiten. Fehler auf dem Übertragungsweg oder der Ausfall von beteiligten Prozessen können durch Vektoruhren lediglich erkannt, jedoch nicht direkt verhindern oder ausgebessert werden. Dies bleibt weiterhin Aufgabe der Anwendungsebene.
\subsection{Ausblick}
Die grundlegende Funktionsweise von Vektoruhren ist bereits ein sehr interessantes und umfangreiches Thema. In der Literatur finden sich aufbauend darauf noch viele weitere Einsatzmöglichkeiten für diese Art der logischen Uhren.

Dabei lassen sich grundsätzlich zwei verschiedene Varianten unterscheiden. Die erste nimmt Vektoruhren als Basis und ändert deren Funktionalität derart ab, sodass damit ein spezielles Problem gelöst werden kann. Die zweite Variante nimmt Vektoruhren in der Funktionsweise, wie sie auch in dieser Arbeit beschrieben wurde und setzt sie für Anwendungen ein, die sich von der Ursprünglichen Idee der kausalen Ordnung von Nachrichten in verteilten Systemen unterscheidet. Im Folgenden werden für beide Fälle einige interessante Beispiele aus der Literatur gezeigt.

Die effiziente Speicherung von Vektoruhren ist, wie sich herausgestellt hat, in großen Systemen mit vielen beteiligten Prozessen ein Problem. Neben der in dieser Arbeit vorgestellten Lösung über Matrixuhren gibt es noch weitere, weitaus effizientere aber auch komplexere Ansätze für die Lösung dieses Problems. Eines davon sind die in \cite{Gidenstam2004} vorgestellten NUREV-Clocks, was ausgeschreiben für \textit{Non-Uniformly Mapped R-Entries Vector Clocks} steht. Die Idee dieser Art von Uhren ist es, eine dynamische Zuordnung zwischen den Prozessen in System und deren Einträgen in der Vektoruhr zu schaffen und dabei die Vektorgröße zu beschränken. Im herkömmlichen Fall ist diese starr, jeder Prozess hat also eine feste ID. Die Zuordnungen können während der Laufzeit dann dynamisch angepasst und optimiert werden, was im Endeffekt eine effizientere Speicherung und Übertragung der Vektoruhren während der Kommunikation ermöglicht.

Eine Anwendung, die in eine ähnliche Richtung geht wie NUREV-Clocks, sind \textit{Hierarchische Vektoruhren}. Diese spiele bei Systemen eine Rolle, welche aus physikalischen, geographischen oder administrativen Gründen zu einzelnen Gruppen aus Nodes zusammengefasst sind \cite{Khotimsky1999}[S. 1]. In diesen Systemen ist es wichtig, das Systemverhalten durch kausale Ordnung von Events im Hinblick auf Datenzugriffe, Konsistenzüberwachung und Fehlertoleranz zu überprüfen. Auch hier kommt wieder der Aspekt zum tragen, dass bei großen Systemen mit mehreren Hierarchieebenen der Speicheraufwand für Vektoruhren zur Überwachung sehr groß werden kann. \etal{Khotimsky} haben in  \cite{Khotimsky1999} eine hierarchische Vektoruhr entwickelt, welche über mehrere dieser Ebenen hinweg funktioniert und auf Basis der \textit{plausible logical time} arbeitet. Durch diese Art der Zeit kann ein Mittelweg zwischen Genauigkeit und den Kosten für einen Overhead gefunden werden, sie wurden in \cite{Torres-Rojas1999} eingeführt und arbeiten unabhängig von der Anzahl an Nodes im System.

Ein etwas anderer Anwendungsfall ist eine Ordnung von Events in parallel arbeitenden Systemen. Diese arbeiten nicht verteilt, aber dafür mit mehreren, gleichzeitig ausgeführten Tasks. Im Programmablauf eines solchen Systems wechseln sich sequentielle und parallele Ausführungsschritte ab, was auch als \textit{Nested Parallelism} bezeichnet wird. Die in \cite{Audenaert1997} beschriebene Methode setzt dabei auf die Technik der \textit{Clock Trees}. Der Name wurde gewählt, weil sich im Laufe des Algorithmus eine Baumstruktur aus Vectoruhren bildet.


Für den zweiten Fall, also die Verwendung von Vektoruhren unter einem völlig neuen Kontext, lassen sich einige eher aktuelle, sehr auf serviceorientierte Architekturen und das Thema Social Media spezialisierte Anwendungen finden.
Ein erstes Beispiel hierfür ist das finden von Abhängigkeiten in Web-Services, wie es in \cite{Romano2011} durchgeführt wird. \etal{Romano} haben in ihrer Arbeit eine Methode entwickelt, wie man die Zusammenhänge unterschiedlicher, zusammenarbeitender Web-Services durch den Einsatz von Vektoruhren untersuchen kann. Das Problem bei solchen Systemen ist häufig, das dieses Zusammenspiel undurchsichtig ist und der Aufbau von serviceorientierte Architekturen schwer nachvollzogen werden kann. Eine direkte Folge stellt dabei die leichte Verbesserung der Antwortzeiten des in \cite{Romano2011} beschriebenen Systems durch eine solche Analyse und Anpassung dar.

Heutzutage sind Social-Media Plattformen wie Facebook oder Youtube in aller Munde. Durch die Vernetzung der User untereinander entstehen sehr große und komplexe Strukturen. Das gleiche Phänomen zeigt sich auch bei dem Emailaustausch innerhalb eines Unternehmens. Um die dynamischen Interaktionen und somit den Informationsfluss eines solchen Netzwerkes zu analysieren und darzustellen, können Vektoruhren verwendet werden. \etal{Hsu} \cite{Hsu2014} beschreiben eine Anwendung von Vektoruhren, welche sie als \textit{Variable Social Vector Clocks} benennen. Das Prinzip von \textit{Social Vector Clocks} wurde bereits in \cite{Kossinets2008} entwickelt und von \etal{Hsu} in dem Sinne erweitert, als dass auch unterschiedliche und damit dynamische Distanzen von Freundschaftsbeziehungen betrachtet werden. Dadurch können nicht nur direkte Freundschaften einbezogen werden, sondern auch indirekte über mehrere Freunde hinweg.

Wie man an diesen vielzähligen Beispielen sehen kann, eröffnete die Erfindung von logischen Uhren im allgemeinen und Vektoruhren im speziellen den Weg für viele interessante Weiterentwicklungen im Bereich der verteilten Systeme. Dieser Themenbereich ist auch heute noch sehr aktuell und nimmt mit zunehmender Digitalisierung der Unternehmen sogar noch an Bedeutung zu.